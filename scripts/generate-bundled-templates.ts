#!/usr/bin/env tsx
/**
 * Script to fetch GitLab CI templates and generate bundled-templates.ts
 *
 * Fetches templates from gitlab.com/gitlab-org/gitlab repo and embeds them
 * as TypeScript constants for offline usage.
 */

import * as fs from "fs";
import * as path from "path";
import * as https from "https";
import {fileURLToPath} from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const GITLAB_PROJECT_ID = "278964"; // gitlab-org/gitlab
const TEMPLATE_BASE_PATH = "lib/gitlab/ci/templates";
const OUTPUT_FILE = path.join(__dirname, "../src/bundled-templates.ts");
const CACHE_DIR = path.join(__dirname, "../vendor/gitlab-templates");

// Template directories to fetch
const TEMPLATE_DIRS = ["Workflows", "Jobs", "Security"];

interface TreeItem {
    id: string;
    name: string;
    type: "tree" | "blob";
    path: string;
}

function httpsGet (url: string): Promise<string> {
    return new Promise((resolve, reject) => {
        const req = https.get(url, {headers: {"User-Agent": "gitlab-ci-local"}}, (res) => {
            if (res.statusCode === 301 || res.statusCode === 302) {
                // Follow redirect
                const redirectUrl = res.headers.location;
                if (redirectUrl) {
                    httpsGet(redirectUrl).then(resolve).catch(reject);
                    return;
                }
            }
            if (res.statusCode !== 200) {
                reject(new Error(`HTTP ${res.statusCode}: ${url}`));
                return;
            }
            let data = "";
            res.on("data", (chunk) => data += chunk);
            res.on("end", () => resolve(data));
        });
        req.on("error", reject);
        req.setTimeout(30000, () => {
            req.destroy();
            reject(new Error(`Timeout: ${url}`));
        });
    });
}

async function fetchTreeRecursive (dirPath: string): Promise<string[]> {
    const url = `https://gitlab.com/api/v4/projects/${GITLAB_PROJECT_ID}/repository/tree?path=${encodeURIComponent(dirPath)}&recursive=true&per_page=100`;
    try {
        const response = await httpsGet(url);
        const items: TreeItem[] = JSON.parse(response);
        return items
            .filter((item) => item.type === "blob" && (item.path.endsWith(".yml") || item.path.endsWith(".yaml")))
            .map((item) => item.path);
    } catch (error) {
        console.error(`Failed to fetch tree for ${dirPath}:`, error);
        return [];
    }
}

async function fetchFileContent (filePath: string): Promise<string> {
    const url = `https://gitlab.com/gitlab-org/gitlab/-/raw/HEAD/${filePath}`;
    return httpsGet(url);
}

function getTemplateKey (filePath: string): string {
    // Convert "lib/gitlab/ci/templates/Workflows/Something.yml" to "Workflows/Something.yml"
    return filePath.replace(`${TEMPLATE_BASE_PATH}/`, "");
}

async function main () {
    console.log("Fetching GitLab CI templates...");

    const templates: Record<string, string> = {};

    // Ensure cache directory exists
    fs.mkdirSync(CACHE_DIR, {recursive: true});

    for (const dir of TEMPLATE_DIRS) {
        const dirPath = `${TEMPLATE_BASE_PATH}/${dir}`;
        console.log(`  Fetching ${dir}/...`);

        const files = await fetchTreeRecursive(dirPath);
        console.log(`    Found ${files.length} templates`);

        for (const file of files) {
            const templateKey = getTemplateKey(file);
            const cacheFile = path.join(CACHE_DIR, templateKey);

            // Check cache first
            if (fs.existsSync(cacheFile)) {
                templates[templateKey] = fs.readFileSync(cacheFile, "utf-8");
                continue;
            }

            try {
                const content = await fetchFileContent(file);
                templates[templateKey] = content;

                // Cache the file
                fs.mkdirSync(path.dirname(cacheFile), {recursive: true});
                fs.writeFileSync(cacheFile, content);

                console.log(`    Downloaded: ${templateKey}`);
            } catch (error) {
                console.error(`    Failed to fetch ${file}:`, error);
            }
        }
    }

    // Generate TypeScript file with 4-space indentation and trailing commas
    const jsonStr = JSON.stringify(templates, null, 4);
    // Add trailing comma after last property to satisfy eslint
    const jsonWithTrailingComma = jsonStr.replace(/\n}$/, ",\n}");

    const output = `// Auto-generated by scripts/generate-bundled-templates.ts - DO NOT EDIT
// Contains bundled GitLab CI templates for offline usage
// Regenerate with: npm run generate-templates

export const BUNDLED_TEMPLATES: Record<string, string> = ${jsonWithTrailingComma};
`;

    fs.writeFileSync(OUTPUT_FILE, output);
    console.log(`\nGenerated ${OUTPUT_FILE} with ${Object.keys(templates).length} templates`);
}

main().catch((error) => {
    console.error("Failed to generate templates:", error);
    process.exit(1);
});
